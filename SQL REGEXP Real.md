# 1. 이메일 : @의 앞부분과 뒷부분 추출 REGEXP_SUBSTR(email, '[^@]+', 1, 1)

🤷‍♂️^는 문자열의 시작이라고 하는데 ^는 해당되지 않는다고 하던데 뭐가 맞는거야

✨정규식의 시작 부분에 있을 때: 예를 들어, ^abc는 'abc'로 시작하는 문자열을 찾습니다.
문자 집합 [] 안에 있을 때: 예를 들어, [^abc]는 'a', 'b', 'c'가 아닌 모든 문자를 찾습니다. 뒤에 오는 문자들을 제외한 모든 문자를 의미합니다. 

🤷‍♂️'[^@]+' 는 @를 제외한... +?

✨'[^@]+'는 '@'를 제외한 모든 문자를 의미하며, 그 뒤에 붙는 +는 그러한 문자가 최소 한 개 이상 반복됨을 의미합니다.

사용 예시
이 패턴은 주로 이메일 주소에서 @ 앞의 아이디 부분을 추출할 때 사용됩니다.

예시 문자열: testuser@example.com


[^@]는 't', 'e', 's', 't', 'u', 's', 'e', 'r'과 일치합니다.
+는 이 문자들(testuser)이 하나 이상 연속되므로 전체를 하나의 패턴으로 인식합니다.
최종적으로 '[^@]+'는 @가 나오기 전까지의 testuser를 찾아냅니다.

🤷‍♂️그럼 regexp_substr(email, '[^@]+', 1, 1)이랑 regexp_substr(email, '[^@]+', 1, 2)는 뭔 차이지

✨REGEXP_SUBSTR(email, '[^@]+', 1, 1): 이메일 문자열의 첫 번째(1) 위치부터 시작하여 '@'가 아닌 문자가 연속되는 패턴의 첫 번째(1) 발생을 찾습니다. 따라서 이메일 주소에서 @ 앞의 아이디 부분을 추출합니다.

예시: 'testuser@example.com' → 'testuser'

REGEXP_SUBSTR(email, '[^@]+', 1, 2): 이메일 문자열의 첫 번째(1) 위치부터 시작하여 '@'가 아닌 문자가 연속되는 패턴의 두 번째(2) 발생을 찾습니다. 이 패턴은 @ 뒤에 오는 도메인 부분을 의미합니다.

예시: 'testuser@example.com' → 'example.com'


# 1-1. 하나 더

🤷‍♂️[^ ]+[DEF]는 공백이 아닌 글자가 계속되는데 DEF가 뒤에 나오는 건 뭔 말이야

✨[^ ]+[DEF]는 공백이 아닌 문자가 1개 이상 연속으로 나오고, 그 뒤에 'D' 또는 'E' 또는 'F' 중 하나의 문자가 나오는 패턴을 의미합니다.

🤷‍♂️정확한 DEF가 아니고 D or E or F?

✨네, 맞습니다. [DEF]는 정확히 'D' 또는 'E' 또는 'F' 중 하나의 문자를 의미합니다.

🤷‍♂️정확한 DEF를 찾고싶다면

✨정확히 'DEF'라는 세 글자 조합을 찾고 싶다면, 정규식에 문자 집합 []를 사용하지 않고 그대로 작성해야 합니다.

🤷‍♂️그럼 '[^ ]+DEF' ?

✨네, 맞습니다. **[^ ]+DEF**는 공백이 아닌 글자가 한 개 이상 연속으로 나온 다음, 바로 이어서 DEF라는 문자열이 나오는 패턴을 찾습니다.

# 2. 주민번호 : 를 생일로 변경 REGEXP_REPLACE(jumin, '([0-9]{2})([0-9]{2})([0-9]{2})', '19\1-\2-\3') as "birth"

🤷‍♂️근데 뭔가 뒷자리 숫자들도 멋대로 가지고 오는 것 같아

✨아마도 REGEXP_REPLACE 함수의 동작 방식 때문에 그렇게 보일 수 있습니다. 이 함수는 패턴에 일치하는 부분만 찾아서 대체하기 때문에, 패턴에 일치하지 않는 뒷부분은 그대로 남게 됩니다.

예를 들어, '8812301234567'이라는 주민등록번호가 있다고 가정해 봅시다.

패턴과 일치하지 않은 나머지 1234567은 그대로 남게 됩니다.

결과적으로, REGEXP_REPLACE('8812301234567', '([0-9]{2})([0-9]{2})([0-9]{2})', '19\1-\2-\3')의 최종 결과는 1988-12-301234567이 됩니다.

✔만약 뒷자리까지 포함하여 전체를 대체하고 싶다면, 정규식에 뒷자리 패턴도 추가해야 합니다. 

예를 들어, REGEXP_REPLACE(jumin, '([0-9]{2})([0-9]{2})([0-9]{2})[0-9]{7}', '19\1-\2-\3')와 같이 수정하면 주민번호 전체를 대상으로 하여 앞부분만 변환한 뒤 나머지를 없애게 됩니다.

# 2-1. 하나 더

🤷‍♂️근데 왜 마지막 [0-9]{7}은 괄호를 안 썼어?

✨정규식 [0-9]{7}에 괄호를 사용하지 않은 이유는 캡처 그룹(capture group)으로 묶을 필요가 없기 때문입니다.

괄호 ()의 역할
정규식에서 괄호 ()는 두 가지 주요 역할을 합니다.

그룹화 (Grouping): 여러 문자를 하나의 단위로 묶어서 *, +, ? 같은 수량자를 적용할 때 사용합니다. 예를 들어, (ab)+는 ab라는 패턴이 1번 이상 반복되는 것을 의미합니다.

캡처 (Capturing): 괄호로 묶은 패턴에 일치하는 부분을 별도의 그룹으로 저장합니다. 이 저장된 내용은 \1, \2, \3 같은 **역참조(backreference)**를 통해 나중에 재사용할 수 있습니다.

주민등록번호의 뒷 7자리인 [0-9]{7}은 변환할 필요가 없습니다. 이 부분은 단순히 패턴 매칭에만 사용될 뿐, 추출하거나 다시 활용할 필요가 없으므로 굳이 캡처 그룹으로 묶지 않은 것입니다.

따라서 괄호로 묶지 않은 [0-9]{7}은 **"그냥 숫자 7개가 연속으로 오는구나"**라는 패턴을 찾는 역할만 하고, 그 값은 따로 저장되지 않습니다. 이처럼 필요한 부분만 캡처 그룹으로 지정하면 정규식의 성능을 향상시키고 메모리 낭비를 줄이는 효과도 있습니다.

🤷‍♂️안 묶는게 성능이 늘어나?

✨네, 캡처 그룹으로 묶지 않으면 성능이 미세하게나마 향상될 수 있습니다.

정규식 엔진은 괄호 ()를 만나면 그 안에 있는 내용을 별도의 메모리 공간에 저장해야 합니다. 나중에 역참조(\1, \2 등)로 다시 사용하기 위해서죠. 하지만 캡처할 필요가 없는 부분까지 괄호로 묶으면 불필요한 저장 및 처리 과정이 추가됩니다.

캡처할 필요가 없는 부분을 괄호로 묶지 않으면 불필요한 저장 과정을 생략할 수 있어 성능에 긍정적인 영향을 줍니다. 특히 수백만 건 이상의 데이터를 처리하는 대규모 작업에서는 이러한 차이가 누적되어 더 크게 나타날 수 있습니다.

따라서 정규식 작성 시에는 **'필요한 부분만 캡처한다'**는 원칙을 따르는 것이 좋습니다.

# 3. IP주소 : 점을 다른 문자로 바꾸기 REGEXP_REPLACE(ip, '\.', '/', 1, 1)

🤷‍♂️REGEXP_REPLACE(ip, '\.', '/', 1, 1)는 첫 .만 바꾸는거지

✨네, 맞아요. 

4번째 : 시작 위치: 1

문자열의 첫 번째 위치(1)부터 패턴 찾기를 시작하라는 의미입니다.

5번째 : 발생 횟수: 1

패턴이 처음으로 발생한 곳(1)만 바꾸라는 의미입니다.

🤷‍♂️REGEXP_REPLACE(ip, '\.', '/', 1, 1)에서 2번째랑 3번째 .만 바꾸려면?

✨REGEXP_REPLACE 함수의 4번째 매개변수인 시작 위치와 5번째 매개변수인 발생 횟수를 조절하면 됩니다.

2번째 점(.)만 바꾸려면 REGEXP_REPLACE(ip, '\.', '/', 1, 2)를 사용하면 됩니다.

3번째 점(.)만 바꾸려면 REGEXP_REPLACE(ip, '\.', '/', 1, 3)를 사용하면 됩니다.

만약 두 번째와 세 번째 점을 모두 바꾸고 싶다면, REGEXP_REPLACE를 두 번 중첩해서 사용해야 합니다.

SELECT
  REGEXP_REPLACE(
    REGEXP_REPLACE('192.168.0.1', '\.', '/', 1, 2),  -- 첫 번째: 2번째 점을 '/'로 바꿈
    '\.', '/', 1, 2)                               -- 두 번째: 이제 새로 생긴 2번째 점(원래 3번째 점)을 '/'로 바꿈
FROM dual;

🤷‍♂️첫번째 2번째만 변경하는 것도 중첩 필요한가?

✨네, 첫 번째와 두 번째만 변경하는 것도 중첩이 필요합니다. REGEXP_REPLACE 함수의 occurrence 매개변수는 단 하나의 발생 횟수만 지정할 수 있기 때문입니다.

🤷‍♂️n번째부터 m번째까지를 바꾸고 싶다면 중첩해야 한다는 소리인가

✨네, 맞습니다. SQL의 REGEXP_REPLACE 함수는 한 번의 호출로 여러 개의 특정 발생 횟수를 지정해서 바꾸는 기능을 직접적으로 지원하지 않습니다. 따라서 n번째부터 m번째까지를 바꾸려면 여러 번 중첩해서 사용해야 합니다.
