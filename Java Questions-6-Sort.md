# 1. 버블 소트

3 2 1 5 4

가 있다고 치자.

i = 0 ~ 4      -1

j = 0 ~ 4-i     -1

가장 큰 숫자를 맨 뒤에 띄운다는 뜻으로 버블소트

그래서

3 2 1 5 4

[2 3] 1 5 4

2 [1 3] 5 4

2 1 [3 5] 4

2 1 3 [4 5]

최종적으로 5를 띄우고, 다음엔 4를 띄우고... 이런 식으로 정렬함.


# 2. 선택 정렬

3 2 1 5 4

가 있다고 치자.

i = 0 ~ 4 -1

j = i+1 ~ 4

이것은 (원래는) 가장 작은 숫자의 [배열 위치]를 기억했다가 마지막에 한번만 교체하는 것이다.

그래서...

i = 0 구간에서 

3 2 1 5 4 : 최소위치 1

3 2 1 5 4 : 최소위치 2

3 2 1 5 4 : 최소위치 3

3 2 1 5 4 : 최소위치 3

3 2 1 5 4 : 최소위치 3

마지막에 [1] 2 3 5 4

이런식

# 3. 삽입 정렬

3 2 1 5 4 

가 있다고 치자

i = 1~4

i=1일때

j = while( i-1 ~ 0 )

3 2 1 5 4

3>2라서, 2의 위치에 3을 오른쪽으로 옮기고, 거기에 2를 넣는다

2 3 1 5 4

i=2일때는 어떤가?

3>1이니 우선 1 위치에 3을 놓는다 2 3 3 5 4 (기억 1)

2>1이니 옆으로 2를 놓는다 2 2 3 5 4 (기억1)

기억한 곳에 1을 놓는다. 1 2 3 5 4

이런 식이다.

# 4. 계수 정렬(정수 한정)

그러니까 이건, [배열을 조작]하지 않고

[배열의 원소 갯수를 센 다음 아예 새 배열을 만드는 식] 이다.

# 5. 힙 소트

일단 힙이 뭔지 알아야 한다

heap 덩어리

1. 힙(Heap)이란?

완전 이진트리(Complete Binary Tree) 형태의 자료구조입니다.

부모 노드와 자식 노드 사이에 특정한 우선순위 조건이 있어요.

크게 두 종류가 있습니다:

최대 힙(Max-Heap): 부모 노드가 자식 노드보다 크거나 같다.

최소 힙(Min-Heap): 부모 노드가 자식 노드보다 작거나 같다.


```mermaid
graph TD
    A[시작] --> B{첫 번째};
    B --> C[종료];

이건 오늘 처음 안 예시고...

```mermaid
graph TD
    A[100] --> B[80];
    A --> C[90];
    B --> D[50];
    B --> E[70];
